#!/usr/bin/env bash

# install

DOTFILES_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# To do symlinks better, see http://stackoverflow.com/a/246128/172602
MODS_ENABLED="$DOTFILES_ROOT/enabled"
MODS_AVAILABLE="$DOTFILES_ROOT/available"
readonly DOTFILES_ROOT MODS_ENABLED MODS_AVAILABLE

# Exit if any command returns nonzero or unset variable referenced.
set -o errexit -o pipefail -o nounset

# Allow aliases for functions in this script, such as 'alias info'.
shopt -s expand_aliases

# Make patterns that match nothing disappear instead of treated as string
# Alternative is put just inside for loop: [[ -f $file ]] || continue
shopt -s nullglob


#######################################
# Format text for fancy display
# Globals:
#   None
# Arguments:
#   format  (string) Must be one of: bold, under (for underline), red, green,
#     yellow, blue, magenta, cyan, white, red, purple
#   text    (string) Text to be formatted
# Returns:
#   Echos string wrapped in escape codes for given format
#######################################
fmt() {
  local reset=$(tput sgr0)
  local bold=$(tput bold)
  local under=$(tput smul)
  local red=$(tput setaf 1)
  local green=$(tput setaf 2)
  local yellow=$(tput setaf 3)
  local blue=$(tput setaf 4)
  local magenta=$(tput setaf 5)
  local cyan=$(tput setaf 6)
  local white=$(tput setaf 7)
  local red=$(tput setaf 9)
  local purple=$(tput setaf 13)
  echo "${!1}$2${reset}"
}

#######################################
# Print wrappers for customized status output
# Inspired by similar in @holman/dotfiles
# Globals:
#   fmt  (function) Text formatting
# Arguments:
#   type  (string) Notice type: (i|info)|(u|user)|(o|okay)|(f|fail)
#   text  (string) Text to be wrapped
# Returns:
#   Prints given text prepended by 'info', ' >> ', 'pass' or 'FAIL'
#######################################
print_wrap () {
  local color= text=
  case $1 in
    i | info ) color=blue    text='info' ;;
    u | user ) color=magenta text=' >> ' ;;
    o | okay ) color=green   text='pass' ;;
    f | fail ) color=red     text='FAIL' ;;
    * ) return 1 ;;
  esac
  shift
  printf " %b" "\r  [$(fmt $color "$text")] $@\n"
}
alias info='print_wrap i'
alias user='print_wrap u'
alias okay='print_wrap o'
alias fail='print_wrap f'

#######################################
# Create symlinks and prompt on conflict to skip, overwrite or backup.
# Based on @holman/dotfiles but largely changed logic.
# Globals:
#   overwrite_all (bool) Optional flag
#   backup_all    (bool) Optional flag
#   skip_all      (bool) Optional flag
# Arguments:
#   src (file) Source file
#   dst (file) Directory to put link
# Returns:
#   Prints actions taken.
#######################################
link_file () {
  # set global vars to defaults if not set
  overwrite_all=${overwrite_all:-false}
  backup_all=${backup_all:-false}
  skip_all=${skip_all:-false}

  local src=$1 dst=$2
  local indent=${3:-} # emptry string unless second param set
  local nicesrc=$(fmt bold "$src")
  local nicedst=$(fmt bold "$dst")
  local overwrite= backup= skip= # var=false breaks var=${var:-$var_all}
  local action=

  if ! [[ -f $src || -d $src || -L $src ]]; then
    fail "${indent}Source file $nicesrc does not exist."
    return 1
  fi

  if [[ -f $dst || -d $dst || -L $dst ]]; then
    local currentSrc=$(readlink $dst)
    if [[ $currentSrc = $src ]]; then
      okay "${indent}$nicedst already points to $nicesrc"
      return 0
    fi

    if [[ $overwrite_all = false && $backup_all = false && $skip_all = false ]]; then
      info "${indent}Attempting to link to $(fmt bold "$(basename "$src")")."
      user "${indent}File $nicedst already exists. What do you want to do?"
      user "${indent}[s]kip, [S]kip all," \
        '[o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all'
      read -n 1 action
      case $action in
        o ) overwrite=true ;;
        O ) overwrite_all=true ;;
        b ) backup=true ;;
        B ) backup_all=true ;;
        s ) skip=true ;;
        S ) skip_all=true ;;
        * ) ;;
      esac
    fi

    # assumes initialized with 'var=' not 'var=false'
    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [[ $skip = true ]]; then
      okay "${indent}Skipped $nicesrc."
      return 0
    else
      if [[ $overwrite = true ]]; then
        #TODO rm -rf "$dst" &&
        info "${indent}Removed $nicedst."
      elif [[ $backup = true ]]; then
        local bck="${dst}.$(date "+%Y%m%d_%H%M%S").backup"
        #TODO mv "$dst" "$bck" &&
        info "${indent}Moved $nicedst to $(fmt bold "$bck")."
      fi
    fi
  fi

  #TODO ln -s "$1" "$2" &&
  okay "${indent}Linked $(fmt bold "$1") to $(fmt bold "$2")."
}

#######################################
# Tests the link_file function with simple end result sanity check when using
# overwrite_all=true or backup_all=true or skip_all=true.
# Globals:
#   link_file  (function)
# Arguments:
#   None
# Returns:
#   Prints actions taken.
#######################################
link_file_test () {
  local temp_dir="link_file_test_$(date "+%Y%m%d_%H%M%S")"
  local tests=(overwrite_all backup_all skip_all)
  mkdir "$temp_dir"
  cd "$temp_dir"
  for testing in "${tests[@]}"; do
    info "$(fmt bold "$testing=true") test commencing."
    eval ${testing}=true

    # set up files
    mkdir -p sources
    mkdir -p links
    touch sources/file1.symlink
    touch links/file2
    touch sources/file3.symlink
    touch links/file3
    link_file "sources/file1.symlink" "links/file1"
    if link_file "sources/file2.symlink" "links/file2" > /dev/null; then
      fail "$(fmt bold link_file) did not fail despite" \
        "$(fmt bold 'sources/file2.symlink') not existing."
    else
      touch sources/file2.symlink
      link_file "sources/file2.symlink" "links/file2"
    fi
    link_file "sources/file3.symlink" "links/file3"

    # verify files
    list=$(ls -l links sources)
    expectations=()
    expectations+=('file1 -> sources/file1.symlink')
    if [[ $testing != 'skip_all' ]]; then
      expectations+=('file2 -> sources/file2.symlink')
      expectations+=('file3 -> sources/file3.symlink')
    fi
    if [[ $testing = 'backup_all' ]]; then
      expectations+=('file2\.[_0-9]{15}\.backup')
      expectations+=('file3\.[_0-9]{15}\.backup')
    fi
    for i in "${expectations[@]}"; do
      if [[ ! $list =~ $i ]]; then
        fail "Test of $(fmt bold link_file) failed to find $(fmt bold "$i")"
        return 1
      fi
    done

    # clean up this subtest
    eval ${testing}=false
    rm -rf sources
    rm -rf links
  done
  cd ..
  rm -rf "$temp_dir"
  okay "Test of $(fmt bold link_file) completed."
}

#######################################
# Enable and install a module
# Globals:
#   MODS_AVAILABLE (string) Path to all modules that can be installed.
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
enable_module () {
  local module=$1
  local indent=${2:-'- '} # '- ' unless second param set
  local nice_name=$(fmt bold "$module")
  info "${indent}Enabling module $nice_name."
  if [[ -d "$MODS_AVAILABLE/$module" ]]; then
    if [[ -h "$MODS_ENABLED/$module" ]]; then
      info "${indent}$nice_name was already enabled."
    else
      ln -s "../available/$module" "$MODS_ENABLED"
      okay "${indent}$nice_name is now enabled."
      install_module "$module" "$indent- "
    fi
  else
    if [[ -h "$MODS_ENABLED/$module" ]]; then
      info "${indent}$nice_name was already enabled," \
        "but it cannot be reenabled if disabled."
    else
      fail "${indent}Cannot find module $nice_name."
      return 1
    fi
  fi
  okay "${indent}Done."
}
alias enmod='enable_module'


#######################################
# Uninstall and disable a module
# Globals:
#   MODS_AVAILABLE (string) Path to all modules that can be installed.
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
disable_module () {
  local module=$1
  local indent=${2:-'- '} # '- ' unless second param set
  local nice_name=$(fmt bold $module)
  info "${indent}Disabling module $nice_name."
  if [[ -h "$MODS_ENABLED/$module" ]]; then
    uninstall_module "$module" "$indent- "
    rm -f "$MODS_ENABLED/$module"
    if [[ -d "$MODS_AVAILABLE/$module" ]]; then
      okay "${indent}$nice_name is now disabled and can be reenabled" \
        "with $(fmt bold "enmod $module")."
    else
      okay "${indent}$nice_name is now disabled and cannot be reenabled" \
        "because it was nonstandard."
    fi
  else
    if [[ -d "$MODS_AVAILABLE/$module" ]]; then
      info "${indent}$nice_name was already disabled."
    else
      info "${indent}$nice_name was not enabled and cannot be enabled."
    fi
  fi
  okay "${indent}Done."
}
alias dismod='disable_module'

#######################################
# Install an enabled module
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
install_module () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local nice_name=$(fmt bold "$module")
  local count=0
  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${indent}Cannot find module $nice_name."
    return 1
  fi
  install_module_dotfiles "$module" "$indent- "
  info "${indent}Checking for module $nice_name installers."
  for file in "$MODS_ENABLED/$module"/install*; do
    case $file in
      *.sh | *.bash )
        info "${indent}Executing installer $(fmt bold "$file")."
        (( count++ ))
        source "$file"
        ;;
      * )
        fail "${indent}Found $(fmt bold "$file"), but installers must" \
          "end in $(fmt bold ".sh") or $(fmt bold ".bash")."
        return 1
        ;;
    esac
  done
  (( count == 0 )) && info "${indent}Module $nice_name has no installers."
  update_module "$module" "$indent- "
  (( count != 0 )) && okay "${indent}Done."
}

#######################################
# Update an enabled module
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
update_module () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local nice_name=$(fmt bold "$module")
  local count=0
  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${indent}Cannot find module $nice_name."
    return 1
  fi
  info "${indent}Checking for module $nice_name updaters."
  for file in "$MODS_ENABLED/$module"/update*; do
    case $file in
      *.sh | *.bash )
        info "${indent}Executing updater $(fmt bold "$file")."
        (( count++ ))
        source "$file"
        ;;
      * )
        fail "${indent}Found $(fmt bold "$file"), but updaters must" \
          "end in $(fmt bold ".sh") or $(fmt bold ".bash")."
        return 1
        ;;
    esac
  done
  (( count == 0 )) && info "${indent}Module $nice_name has no updaters."
  local brewfile=$MODS_ENABLED/$module/Brewfile
  if [[ -f $brewfile ]]; then
    info "${indent}Checking for module $nice_name Homebrew updates."
    if ! brew bundle check --file="$brewfile"; then
      info "${indent}Installing module $nice_name Homebrew updates."
      brew bundle --file="$brewfile"
    fi
  fi
  okay "${indent}Done."
}

#######################################
# Uninstall a module
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
uninstall_module () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local nice_name=$(fmt bold "$module")
  local count=0
  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${indent}Cannot find module $nice_name."
    return 1
  fi
  info "${indent}Checking for module $nice_name uninstallers."
  for file in "$MODS_ENABLED/$module"/uninstall*; do
    case $file in
      *.sh | *.bash )
        info "${indent}Executing uninstaller $(fmt bold "$file")."
        (( count++ ))
        source "$file"
        ;;
      * )
        fail "${indent}Found $(fmt bold "$file"), but uninstallers must" \
          "end in $(fmt bold ".sh") or $(fmt bold ".bash")."
        return 1
        ;;
    esac
  done
  (( count > 0 )) || info "${indent}Module $nice_name has no uninstallers."
  okay "${indent}Done."
}

#######################################
# Install an enabled module's dotfiles
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
install_module_dotfiles () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local nice_name=$(fmt bold "$module")
  local count=0
  if [[ -h "$MODS_ENABLED/$module" ]]; then
    info "${indent}Checking for module $nice_name dotfiles."
    for src in "$MODS_ENABLED/$module"/*.symlink; do
      dst="$HOME/.$(basename "${src%.*}")"
      link_file "$src" "$dst" "$indent- "
      (( count++ ))
    done
    (( count > 0 )) || info "${indent}Module $nice_name has no dotfiles."
  else
    fail "${indent}Cannot find module $nice_name."
    return 1
  fi
  okay "${indent}Done."
}

#######################################
# Remove Homebrew installed programs that are not in the cumulative Brewfiles
# Globals:
#   DOTFILES_ROOT  (string) Application directory.
# Arguments:
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
cleanup () {
  local indent=${1:-} # empty string unless second param set
  local brewcommand="find -H \"$DOTFILES_ROOT\" -not \( -path available -prune \) -name Brewfile -print0 | xargs -0 cat | brew bundle cleanup --file=-"
  local result
  eval "result=\$($brewcommand)"
  if [[ $result =~ 'Would uninstall formulae' ]]; then
    info "${indent}The following Homebrew programs that were manually installed:"
    result=$(echo "$result" | tail -n +2 | tr '\n' ',')
    result=${result%,}
    info "${indent}$(fmt bold "${result//,/, }")"
    user "${indent}Uninstall?  $(fmt bold 'n/Y')"
    while read -n 1 action; do
      case $action in
        n )
          info "${indent}All right, they will be left alone."
          break
          ;;
        Y )
          info "${indent}Uninstalling."
          eval "$brewcommand --force" > /dev/null
          if (( $? != 0 )); then
            fail "${indent}Error uninstalling."
            return 1
          else
            okay "${indent}Done."
          fi
          break
          ;;
        * )
          fail "${indent}$(fmt bold "$action") is not valid. Enter $(fmt bold n) or $(fmt bold Y)."
          ;;
      esac
    done
  fi
}







main () {
  info 'Installing.'

  # Make sure we have brew bundle and mac app store tie in
  if [ "$(uname -s)" == "Darwin" ]
  then
    brew tap Homebrew/bundle
    if ! brew ls --versions mas > /dev/null; then
      brew install mas
    fi
    local brewfile=$DOTFILES_ROOT/Brewfile
    if [[ -f $brewfile ]]; then
      info 'Checking for Homebrew updates.'
      if ! brew bundle check --file="$brewfile" > /dev/null; then
        info 'Installing Homebrew updates.'
        brew bundle --file="$brewfile"
      fi
    fi
    cleanup '- '
  fi

  #enmod git
  #dismod git

  okay "Done."

}

main "$@"

