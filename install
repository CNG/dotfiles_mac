#!/usr/bin/env bash

# install

DOTFILES_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# To do symlinks better, see http://stackoverflow.com/a/246128/172602
MODS_ENABLED="$DOTFILES_ROOT/enabled"
MODS_AVAILABLE="$DOTFILES_ROOT/available"
readonly DOTFILES_ROOT MODS_ENABLED MODS_AVAILABLE

# Exit if any command returns nonzero or unset variable referenced.
set -o errexit -o pipefail -o nounset

# Allow aliases for functions in this script, such as 'alias info'.
shopt -s expand_aliases

# Make patterns that match nothing disappear instead of treated as string
# Alternative is put just inside for loop: [[ -f $file ]] || continue
shopt -s nullglob


#######################################
# Format text for fancy display
# Globals:
#   None
# Arguments:
#   format  (string) Must be one of: bold, under (for underline), red, green,
#     yellow, blue, magenta, cyan, white, red, purple
#   text    (string) Text to be formatted
# Returns:
#   Echos string wrapped in escape codes for given format
#######################################
fmt() {
  local reset=$(tput sgr0)
  local bold=$(tput bold)
  local under=$(tput smul)
  local red=$(tput setaf 1)
  local green=$(tput setaf 2)
  local yellow=$(tput setaf 3)
  local blue=$(tput setaf 4)
  local magenta=$(tput setaf 5)
  local cyan=$(tput setaf 6)
  local white=$(tput setaf 7)
  local red=$(tput setaf 9)
  local purple=$(tput setaf 13)
  echo "${!1}$2${reset}"
}

#######################################
# Print wrappers for customized status output
# Inspired by similar in @holman/dotfiles
# Globals:
#   fmt  (function) Text formatting
# Arguments:
#   type  (string) Notice type: (i|info)|(u|user)|(o|okay)|(f|fail)
#   text  (string) Text to be wrapped
# Returns:
#   Prints given text prepended by 'info', ' >> ', 'pass' or 'FAIL'
#######################################
print_wrap () {
  local color= text=
  case $1 in
    i | info ) color=blue    text='info' ;;
    u | user ) color=magenta text=' >> ' ;;
    o | okay ) color=green   text='pass' ;;
    f | fail ) color=red     text='FAIL' ;;
    * ) return 1 ;;
  esac
  shift
  printf " %b" "\r  [$(fmt $color "$text")] $@\n"
}
alias info='print_wrap i'
alias user='print_wrap u'
alias okay='print_wrap o'
alias fail='print_wrap f'

#######################################
# Create symlinks and prompt on conflict to skip, overwrite or backup.
# Based on @holman/dotfiles but largely changed logic.
# Globals:
#   overwrite_all (bool) Optional flag
#   backup_all    (bool) Optional flag
#   skip_all      (bool) Optional flag
# Arguments:
#   src (file) Source file
#   dst (file) Directory to put link
# Returns:
#   Prints actions taken.
#######################################
link_file () {
  # set global vars to defaults if not set
  overwrite_all=${overwrite_all:-false}
  backup_all=${backup_all:-false}
  skip_all=${skip_all:-false}

  local src=$1 dst=$2
  local indent=${3:-} # emptry string unless second param set
  local nicesrc=$(fmt bold "$src")
  local nicedst=$(fmt bold "$dst")
  local overwrite= backup= skip= # var=false breaks var=${var:-$var_all}
  local action=

  if ! [[ -f $src || -d $src || -L $src ]]; then
    fail "${indent}Source file $nicesrc does not exist."
    return 1
  fi

  if [[ -f $dst || -d $dst || -L $dst ]]; then
    local currentSrc=$(readlink $dst)
    if [[ $currentSrc = $src ]]; then
      okay "${indent}$nicedst already points to $nicesrc"
      return 0
    fi

    if [[ $overwrite_all = false && $backup_all = false && $skip_all = false ]]; then
      info "${indent}Attempting to link to $(fmt bold "$(basename "$src")")."
      user "${indent}File $nicedst already exists. What do you want to do?"
      user "${indent}[s]kip, [S]kip all," \
        '[o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all'
      read -n 1 action
      case $action in
        o ) overwrite=true ;;
        O ) overwrite_all=true ;;
        b ) backup=true ;;
        B ) backup_all=true ;;
        s ) skip=true ;;
        S ) skip_all=true ;;
        * ) ;;
      esac
    fi

    # assumes initialized with 'var=' not 'var=false'
    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [[ $skip = true ]]; then
      okay "${indent}Skipped $nicesrc."
      return 0
    else
      if [[ $overwrite = true ]]; then
        #TODO rm -rf "$dst" &&
        info "${indent}Removed $nicedst."
      elif [[ $backup = true ]]; then
        local bck="${dst}.$(date "+%Y%m%d_%H%M%S").backup"
        #TODO mv "$dst" "$bck" &&
        info "${indent}Moved $nicedst to $(fmt bold "$bck")."
      fi
    fi
  fi

  #TODO ln -s "$1" "$2" &&
  okay "${indent}Linked $(fmt bold "$1") to $(fmt bold "$2")."
}

#######################################
# Tests the link_file function with simple end result sanity check when using
# overwrite_all=true or backup_all=true or skip_all=true.
# Globals:
#   link_file  (function)
# Arguments:
#   None
# Returns:
#   Prints actions taken.
#######################################
link_file_test () {
  local temp_dir="link_file_test_$(date "+%Y%m%d_%H%M%S")"
  local tests=(overwrite_all backup_all skip_all)
  mkdir "$temp_dir"
  cd "$temp_dir"
  for testing in "${tests[@]}"; do
    info "$(fmt bold "$testing=true") test commencing."
    eval ${testing}=true

    # set up files
    mkdir -p sources
    mkdir -p links
    touch sources/file1.symlink
    touch links/file2
    touch sources/file3.symlink
    touch links/file3
    link_file "sources/file1.symlink" "links/file1"
    if link_file "sources/file2.symlink" "links/file2" > /dev/null; then
      fail "$(fmt bold link_file) did not fail despite" \
        "$(fmt bold 'sources/file2.symlink') not existing."
    else
      touch sources/file2.symlink
      link_file "sources/file2.symlink" "links/file2"
    fi
    link_file "sources/file3.symlink" "links/file3"

    # verify files
    list=$(ls -l links sources)
    expectations=()
    expectations+=('file1 -> sources/file1.symlink')
    if [[ $testing != 'skip_all' ]]; then
      expectations+=('file2 -> sources/file2.symlink')
      expectations+=('file3 -> sources/file3.symlink')
    fi
    if [[ $testing = 'backup_all' ]]; then
      expectations+=('file2\.[_0-9]{15}\.backup')
      expectations+=('file3\.[_0-9]{15}\.backup')
    fi
    for i in "${expectations[@]}"; do
      if [[ ! $list =~ $i ]]; then
        fail "Test of $(fmt bold link_file) failed to find $(fmt bold "$i")"
        return 1
      fi
    done

    # clean up this subtest
    eval ${testing}=false
    rm -rf sources
    rm -rf links
  done
  cd ..
  rm -rf "$temp_dir"
  okay "Test of $(fmt bold link_file) completed."
}

#######################################
# Enable and install a module
# Globals:
#   MODS_AVAILABLE (string) Path to all modules that can be installed.
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
enable_module () {
  local module=$1
  local indent=${2:-'| '} # '| ' unless second param set
  local outer=$indent
  local inner="$indent| "
  local nice_name=$(fmt bold "$module")

  info "${outer}Enabling module $nice_name."
  if [[ -d "$MODS_AVAILABLE/$module" ]]; then
    if [[ -h "$MODS_ENABLED/$module" ]]; then
      info "${inner}Module $nice_name was already enabled."
    else
      ln -s "../available/$module" "$MODS_ENABLED"
      #info "${inner}Module $nice_name is now enabled."
      trap_term_signal () {
        fail "${inner}TERMINATING DUE TO SIGNAL"
        disable_module "$module" "$inner"
        exit
      }
      trap_fail () {
        fail "${inner}Disabling module without uninstalling due to failure."
        user "Resolve error and run command: $(fmt bold "enmod $module")"
        rm -f "$MODS_ENABLED/$module"
        exit
      }
      trap trap_cleanup INT TERM
      trap trap_fail EXIT
      install_module "$module" "$inner"
      trap - INT TERM EXIT
    fi
  else
    if [[ -h "$MODS_ENABLED/$module" ]]; then
      info "${inner}Module $nice_name was already enabled," \
        "but it cannot be reenabled if disabled."
    else
      fail "${inner}Cannot find module $nice_name."
      return 1
    fi
  fi
  okay "${outer}Done."
}
alias enmod='enable_module'


#######################################
# Uninstall and disable a module
# Globals:
#   MODS_AVAILABLE (string) Path to all modules that can be installed.
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
disable_module () {
  local module=$1
  local indent=${2:-'| '} # '| ' unless second param set
  local outer=$indent
  local inner="$indent| "
  local nice_name=$(fmt bold $module)

  info "${outer}Disabling module $nice_name."
  if [[ -h "$MODS_ENABLED/$module" ]]; then
    uninstall_module "$module" "$inner"
    rm -f "$MODS_ENABLED/$module"
    if [[ -d "$MODS_AVAILABLE/$module" ]]; then
      :
      #info "${inner}Modules $nice_name is now disabled and can be reenabled" \
      #  "with $(fmt bold "enmod $module")."
    else
      info "${inner}Module $nice_name is now disabled and cannot be reenabled" \
        "because it was nonstandard."
    fi
  else
    if [[ -d "$MODS_AVAILABLE/$module" ]]; then
      info "${inner}Module $nice_name was already disabled."
    else
      info "${inner}Module $nice_name was not enabled and cannot be enabled."
    fi
  fi
  okay "${outer}Done."
}
alias dismod='disable_module'

#######################################
# Install an enabled module
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
install_module () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local outer=$indent
  local inner="$indent| "
  local nice_name=$(fmt bold "$module")
  local count=0

  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${outer}Cannot find module $nice_name."
    return 1
  fi

  install_module_dotfiles "$module" "$outer"

  # Run any install scripts, named install*.[ba]sh
  info "${outer}Checking for module $nice_name installers."
  for file in "$MODS_ENABLED/$module"/install*; do
    case $file in
      *.sh | *.bash )
        info "${inner}Executing installer $(fmt bold "$file")."
        (( count++ ))
        source "$file"
        ;;
      * )
        fail "${inner}Found $(fmt bold "$file"), but installers must" \
          "end in $(fmt bold ".sh") or $(fmt bold ".bash")."
        return 1
        ;;
    esac
  done
  (( count == 0 )) && info "${inner}Module $nice_name has no installers."
  okay "${outer}Done."

  update_module "$module" "$outer"
}

#######################################
# Update an enabled module
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
update_module () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local outer=$indent
  local inner="$indent| "
  local nice_name=$(fmt bold "$module")
  local count=0

  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${outer}Cannot find module $nice_name."
    return 1
  fi

  # Run any update scripts, named update*.[ba]sh
  info "${outer}Checking for module $nice_name updaters."
  for file in "$MODS_ENABLED/$module"/update*; do
    case $file in
      *.sh | *.bash )
        info "${inner}Executing updater $(fmt bold "$file")."
        (( count++ ))
        source "$file"
        ;;
      * )
        fail "${inner}Found $(fmt bold "$file"), but updaters must" \
          "end in $(fmt bold ".sh") or $(fmt bold ".bash")."
        return 1
        ;;
    esac
  done
  (( count == 0 )) && info "${inner}Module $nice_name has no updaters."
  okay "${outer}Done."

  # Process any package manifests, named Brewfile
  local manifest=$MODS_ENABLED/$module/Brewfile
  if [[ -f $manifest ]]; then
    if [[ ! -h "$MODS_ENABLED/brew" ]]; then
      fail "${outer}Need module $(fmt bold "brew") to process manifest."
      disable_module "$module" "$inner"
      user "Run command: $(fmt bold "enmod brew")"
      return 1
    fi
    info "${outer}Checking for module $nice_name package updates."
    if ! brew bundle check --file="$manifest" > /dev/null; then

      info "${inner}Installing module $nice_name package updates."
      # run update command and fix any "already app" errors 
      if ! command_log=$(brew bundle --file="$manifest"); then
        # disabling version that outputs by default. let's hide unless cannot resolve
        # /dev/tty idea from http://stackoverflow.com/a/12451419/172602 comment
        #if ! command_log=$(brew bundle --file="$manifest" | tee /dev/tty); then
        info "${inner}| Updates failed. Attempting resolution."
        command_log=$(echo "$command_log" | grep 'It seems there is already an App')
        local resolution=0
        local line
        while read -r line; do
          line=${line#*already an App at \'}
          line=${line%\'.}
          trash_file "$line" "$inner| " || resolution=1
        done <<< "$command_log"
        if (( resolution == 1 )); then
          fail "${inner}| Could not resolve. Here is the log of what failed."
          echo "$command_log"
          return resolution
        else
          info "${inner}| Successfully resolved errors. Updating again."
          command_log=$(brew bundle --file="$manifest") ||
            { echo "$command_log"; return 1; }
        fi
      fi
      okay "${inner}Done."

    fi
    okay "${outer}Done."
  fi
}

#######################################
# Uninstall a module
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
uninstall_module () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local outer=$indent
  local inner="$indent| "
  local nice_name=$(fmt bold "$module")
  local count=0
  local line
  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${outer}Cannot find module $nice_name."
    return 1
  fi

  # Run any uninstall scripts, named uninstall*.[ba]sh
  info "${outer}Checking for module $nice_name uninstallers."
  for file in "$MODS_ENABLED/$module"/uninstall*; do
    case $file in
      *.sh | *.bash )
        info "${inner}Executing uninstaller $(fmt bold "$file")."
        (( count++ ))
        source "$file"
        ;;
      * )
        fail "${inner}Found $(fmt bold "$file"), but uninstallers must" \
          "end in $(fmt bold ".sh") or $(fmt bold ".bash")."
        return 1
        ;;
    esac
  done
  (( count > 0 )) || info "${inner}Module $nice_name has no uninstallers."
  okay "${outer}Done."

  # Uninstall packages from manifests, named Brewfile
  local manifest=$MODS_ENABLED/$module/Brewfile
  if [[ -f $manifest ]]; then
    info "${outer}Checking for module $nice_name manifest packages to remove."
    cat "$manifest" | tr -s " " | # squash spaces and pass to loop
    {
      while read -r line; do
        line=${line%,*} # keep up to first comma
        line=${line//\'/} # hope package names don't contain single quotes
        line=${line//\"/} # hope package names don't contain double quotes
        case $line in
          '#'* ) ;; # ignore comments
          'brew '* )
            brew uninstall "${line#brew }"
            ;;
          'cask '* )
            brew cask uninstall "${line#cask }"
            ;;
          'mas '*  )
            trash_file "/Applications/${line#mas }.app" "$inner"
            ;;
          *  )
            info "${inner}Unsure how to handle line:"
            info "${inner}| $(fmt bold "$line")"
            ;;
        esac
      done
    }
    okay "${outer}Done."
  fi
}

trash_file () {
  local item=$1
  local indent=${2:-} # empty string unless second param set
  if [[ -d $item || -f $item ]]; then
    info "${indent}Trashing $(fmt bold "$item")"
    if test ! $(which trash); then
      brew install trash
      trash "$item"
      brew uninstall trash
    else
      trash "$item"
    fi
  fi
}

#######################################
# Install an enabled module's dotfiles
# Globals:
#   MODS_ENABLED   (string) Path to symlinks indicating installed modules.
# Arguments:
#   module  (string) Name of module
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
install_module_dotfiles () {
  local module=$1
  local indent=${2:-} # empty string unless second param set
  local outer=$indent
  local inner="$indent| "
  local nice_name=$(fmt bold "$module")
  local count=0

  if [[ ! -h "$MODS_ENABLED/$module" ]]; then
    fail "${outer}Cannot find module $nice_name."
    return 1
  fi

  info "${outer}Checking for module $nice_name dotfiles."
  for src in "$MODS_ENABLED/$module"/*.symlink; do
    dst="$HOME/.$(basename "${src%.*}")"
    link_file "$src" "$dst" "$inner"
    (( count++ ))
  done
  (( count > 0 )) || info "${inner}Module $nice_name has no dotfiles."

  okay "${outer}Done."
}

#######################################
# Remove Homebrew installed programs that are not in the cumulative Brewfiles
# Globals:
#   DOTFILES_ROOT  (string) Application directory.
# Arguments:
#   indent  (string) Optional text to prepend to messages
# Returns:
#   None
#######################################
cleanup () {
  local indent=${1:-} # empty string unless second param set
  local outer=$indent
  local inner="$indent| "
  local brewcommand="find -H \"$DOTFILES_ROOT\" -not \( -path available -prune \) -name Brewfile -print0 | xargs -0 cat | brew bundle cleanup --file=-"
  local result
  local action
  eval "result=\$($brewcommand)"
  if [[ $result =~ 'Would uninstall formulae' ]]; then
    info "${indent}The following Homebrew programs that were manually installed:"
    result=$(echo "$result" | tail -n +2 | tr '\n' ',')
    result=${result%,}
    info "${indent}$(fmt bold "${result//,/, }")"
    user "${indent}Uninstall?  $(fmt bold 'n/Y')"
    while read -n 1 action; do
      case $action in
        n )
          info "${indent}All right, they will be left alone."
          break
          ;;
        Y )
          info "${indent}Uninstalling."
          eval "$brewcommand --force" > /dev/null
          if (( $? != 0 )); then
            fail "${indent}Error uninstalling."
            return 1
          else
            okay "${indent}Done."
          fi
          break
          ;;
        * )
          fail "${indent}$(fmt bold "$action") is not valid. Enter $(fmt bold n) or $(fmt bold Y)."
          ;;
      esac
    done
  fi
}







main () {
  info 'Installing.'

  enmod brew
  enmod games
  enmod chat

  #enmod git
  #dismod git


  #cleanup '| '
  okay "Done."
}

main "$@"

